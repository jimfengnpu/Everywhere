<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Tree Traversal Debugger</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 0; display: flex; height: 100vh; overflow: hidden; }
        #sidebar { width: 350px; background: #f5f5f7; border-right: 1px solid #d1d1d6; display: flex; flex-direction: column; }
        #main { flex: 1; position: relative; overflow: hidden; background: #fff; }
        #controls { padding: 10px; border-bottom: 1px solid #d1d1d6; background: #fff; }
        #step-info { padding: 10px; flex: 1; overflow-y: auto; }
        #graph-container { width: 100%; height: 100%; }
        
        .node rect { stroke: #333; stroke-width: 1.5px; }
        .node text { font-size: 10px; pointer-events: none; }
        .link { fill: none; stroke: #ccc; stroke-width: 1.5px; }
        
        .status-visited { fill: #e1f5fe; stroke: #0288d1; }
        .status-enqueued { fill: #fff9c4; stroke: #fbc02d; }
        .status-core { stroke: #d32f2f; stroke-width: 3px; }
        .status-current { fill: #c8e6c9 !important; stroke: #388e3c !important; stroke-width: 3px; }
        
        .step-item { padding: 8px; border-bottom: 1px solid #eee; cursor: pointer; }
        .step-item:hover { background: #f0f0f0; }
        .step-item.active { background: #e3f2fd; border-left: 4px solid #2196f3; }
        
        #drop-zone { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255,255,255,0.9); display: flex; align-items: center; justify-content: center; z-index: 1000; font-size: 24px; color: #666; border: 4px dashed #ccc; margin: 20px; display: none; }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>

<div id="sidebar">
    <div id="controls">
        <h3>Traversal Debugger</h3>
        <input type="file" id="file-input" accept=".json" />
        <div style="margin-top: 10px; display: flex; gap: 5px;">
            <button id="btn-prev">Prev</button>
            <button id="btn-play">Play</button>
            <button id="btn-next">Next</button>
        </div>
        <div style="margin-top: 5px;">
            Step: <span id="lbl-step">0</span> / <span id="lbl-total">0</span>
        </div>
        <div style="margin-top: 5px;">
            Tokens: <span id="lbl-tokens">0</span> / <span id="lbl-limit">0</span>
        </div>
    </div>
    <div id="step-info">
        <!-- Step list goes here -->
    </div>
</div>

<div id="main">
    <div id="graph-container"></div>
    <div id="drop-zone">Drop debug_session.json here</div>
</div>

<script>
    let sessionData = null;
    let currentStepIndex = -1;
    let simulationTimer = null;
    
    // D3 setup
    const svg = d3.select("#graph-container").append("svg")
        .attr("width", "100%")
        .attr("height", "100%");
    const g = svg.append("g");
    
    const zoom = d3.zoom().on("zoom", (e) => g.attr("transform", e.transform));
    svg.call(zoom);

    // Data structures for graph
    let nodes = [];
    let links = [];
    let nodeMap = new Map();
    let rootNode = null;

    function loadData(json) {
        sessionData = json;
        document.getElementById("lbl-limit").innerText = sessionData.tokenLimit;
        document.getElementById("lbl-total").innerText = sessionData.steps.length;
        
        // Build tree structure from AllNodes
        nodes = sessionData.allNodes.map(n => ({
            id: n.id,
            data: n,
            width: 120,
            height: 40
        }));
        
        nodeMap = new Map(nodes.map(n => [n.id, n]));
        links = [];
        
        nodes.forEach(n => {
            if (n.data.childrenIds) {
                n.data.childrenIds.forEach(childId => {
                    if (nodeMap.has(childId)) {
                        links.push({ source: n.id, target: childId });
                    }
                });
            }
        });

        // Layout (using d3-hierarchy for tree layout)
        // We need to find the root(s). For simplicity, let's assume one root or handle forest.
        // Or use d3-dagre or force layout. Tree layout is best for visual tree.
        // Let's try to reconstruct the hierarchy object.
        
        // Find nodes with no parents in the dataset (roots)
        const childIds = new Set(links.map(l => l.target));
        const roots = nodes.filter(n => !childIds.has(n.id));
        
        if (roots.length === 0 && nodes.length > 0) roots.push(nodes[0]); // Fallback
        
        // Use the first root for now
        const root = d3.stratify()
            .id(d => d.id)
            .parentId(d => {
                const parentLink = links.find(l => l.target === d.id);
                return parentLink ? parentLink.source : null;
            })
            (nodes);

        const treeLayout = d3.tree().nodeSize([140, 80]);
        treeLayout(root);
        
        // Render
        renderGraph(root);
        
        // Reset steps
        setStep(-1);
        renderStepList();
    }

    function renderGraph(root) {
        g.selectAll("*").remove();
        
        const link = g.selectAll(".link")
            .data(root.links())
            .enter().append("path")
            .attr("class", "link")
            .attr("d", d3.linkVertical()
                .x(d => d.x)
                .y(d => d.y));

        const node = g.selectAll(".node")
            .data(root.descendants())
            .enter().append("g")
            .attr("class", "node")
            .attr("transform", d => `translate(${d.x},${d.y})`);

        node.append("rect")
            .attr("width", 120)
            .attr("height", 40)
            .attr("x", -60)
            .attr("y", -20)
            .attr("rx", 5)
            .attr("fill", "#fff");

        node.append("text")
            .attr("dy", "-0.2em")
            .attr("text-anchor", "middle")
            .style("font-weight", "bold")
            .text(d => d.data.data.type);
            
        node.append("text")
            .attr("dy", "1.0em")
            .attr("text-anchor", "middle")
            .text(d => (d.data.data.name || d.data.data.id).substring(0, 15));
            
        // Center view
        const bounds = g.node().getBBox();
        const svgBounds = svg.node().getBoundingClientRect();
        const scale = Math.min(svgBounds.width / bounds.width, svgBounds.height / bounds.height) * 0.8;
        // svg.call(zoom.transform, d3.zoomIdentity.translate(svgBounds.width/2, 50).scale(scale));
    }

    function setStep(index) {
        currentStepIndex = index;
        document.getElementById("lbl-step").innerText = index + 1;
        
        // Update UI
        const step = index >= 0 ? sessionData.steps[index] : null;
        if (step) {
            document.getElementById("lbl-tokens").innerText = step.currentTokens;
        } else {
            document.getElementById("lbl-tokens").innerText = 0;
        }

        // Update Node Styles
        // Replay from start to current index to determine state
        const visited = new Set();
        const enqueued = new Set();
        
        for (let i = 0; i <= index; i++) {
            const s = sessionData.steps[i];
            if (s.action === "Visit") visited.add(s.nodeId);
            if (s.action === "Enqueue") enqueued.add(s.nodeId);
        }
        
        g.selectAll(".node rect")
            .attr("fill", d => {
                if (d.data.id === (step ? step.nodeId : null)) return "#c8e6c9"; // Current
                if (visited.has(d.data.id)) return "#e1f5fe";
                if (enqueued.has(d.data.id)) return "#fff9c4";
                return "#fff";
            })
            .attr("stroke", d => {
                if (d.data.id === (step ? step.nodeId : null)) return "#388e3c";
                if (d.data.data.isCore) return "#d32f2f";
                if (visited.has(d.data.id)) return "#0288d1";
                if (enqueued.has(d.data.id)) return "#fbc02d";
                return "#333";
            })
            .attr("stroke-width", d => {
                if (d.data.id === (step ? step.nodeId : null)) return 3;
                if (d.data.data.isCore) return 3;
                return 1.5;
            });

        // Scroll step list
        const list = document.getElementById("step-info");
        const activeItem = list.children[index];
        if (activeItem) {
            activeItem.scrollIntoView({ block: "center", behavior: "smooth" });
            // Update active class
            Array.from(list.children).forEach(c => c.classList.remove("active"));
            activeItem.classList.add("active");
        }
    }

    function renderStepList() {
        const list = document.getElementById("step-info");
        list.innerHTML = "";
        sessionData.steps.forEach((step, i) => {
            const div = document.createElement("div");
            div.className = "step-item";
            div.innerHTML = `
                <div style="font-weight:bold">${i+1}. ${step.action}</div>
                <div style="font-size:0.9em">${step.nodeId}</div>
                <div style="font-size:0.8em;color:#666">Score: ${step.score.toFixed(2)} | Tokens: ${step.currentTokens}</div>
                <div style="font-size:0.8em;color:#888">${step.reason}</div>
            `;
            div.onclick = () => setStep(i);
            list.appendChild(div);
        });
    }

    // Controls
    document.getElementById("btn-next").onclick = () => {
        if (sessionData && currentStepIndex < sessionData.steps.length - 1) setStep(currentStepIndex + 1);
    };
    document.getElementById("btn-prev").onclick = () => {
        if (sessionData && currentStepIndex > -1) setStep(currentStepIndex - 1);
    };
    document.getElementById("btn-play").onclick = () => {
        if (simulationTimer) {
            clearInterval(simulationTimer);
            simulationTimer = null;
            document.getElementById("btn-play").innerText = "Play";
        } else {
            simulationTimer = setInterval(() => {
                if (sessionData && currentStepIndex < sessionData.steps.length - 1) {
                    setStep(currentStepIndex + 1);
                } else {
                    clearInterval(simulationTimer);
                    simulationTimer = null;
                    document.getElementById("btn-play").innerText = "Play";
                }
            }, 200);
            document.getElementById("btn-play").innerText = "Pause";
        }
    };

    // File handling
    document.getElementById("file-input").onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => loadData(JSON.parse(e.target.result));
        reader.readAsText(file);
    };
    
    // Drag and drop
    window.ondragover = (e) => { e.preventDefault(); document.getElementById("drop-zone").style.display = "flex"; };
    window.ondragleave = (e) => { e.preventDefault(); document.getElementById("drop-zone").style.display = "none"; };
    window.ondrop = (e) => {
        e.preventDefault();
        document.getElementById("drop-zone").style.display = "none";
        const file = e.dataTransfer.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => loadData(JSON.parse(e.target.result));
            reader.readAsText(file);
        }
    };
</script>
</body>
</html>
