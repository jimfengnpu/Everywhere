using System.Collections.Immutable;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Everywhere.Configuration.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class SettingsItemsSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find classes annotated with [GeneratedSettingsItems]
        var candidates = context.SyntaxProvider.CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax { AttributeLists.Count: > 0 },
                static (ctx, _) =>
                {
                    if (ctx.SemanticModel.GetDeclaredSymbol((ClassDeclarationSyntax)ctx.Node) is not INamedTypeSymbol symbol) return null;
                    return symbol.GetAttributes().Any(a => a.AttributeClass?.ToDisplayString() == KnownAttributes.GeneratedSettingsItems) ?
                        symbol :
                        null;
                })
            .Where(static s => s is not null);

        var grouped = context.CompilationProvider.Combine(candidates.Collect());
        context.RegisterSourceOutput(
            grouped,
            static (spc, tuple) =>
            {
                var (compilation, types) = (tuple.Left, tuple.Right);
                foreach (var t in types.Distinct(SymbolEqualityComparer.Default).OfType<INamedTypeSymbol>())
                {
                    EmitForType(spc, compilation, t);
                }
            });
    }

    private static void EmitForType(SourceProductionContext ctx, Compilation compilation, INamedTypeSymbol type)
    {
        if (!type.IsPartial())
        {
            // Report diagnostic for not being a partial class
            ctx.ReportDiagnostic(
                Diagnostic.Create(
                    Diagnostics.MustBePartial,
                    type.Locations.FirstOrDefault(),
                    type.Name));
            return;
        }

        // Collect metadata for all relevant properties of the class
        var members = type.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p is { IsStatic: false, GetMethod: not null, IsImplicitlyDeclared: false })
            .Where(p => !p.IsHiddenItem())
            .Select(p => BuildPropertyMetadata(p, p, p.Name))
            .ToImmutableArray();

        var ns = type.GetNamespace();
        var sb = new IndentedStringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable").AppendLine();
        sb.AppendLine("using System.Reflection;").AppendLine(); // we need this for enum item generation

        if (ns.Length > 0)
        {
            sb.Append("namespace ").Append(ns).AppendLine(";");
            sb.AppendLine();
        }

        sb.Append("partial class ").Append(type.Name).AppendLine();
        sb.AppendLine("{");
        using (sb.Indent())
        {
            sb.AppendLine("[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]").AppendLine();
            sb.AppendLine("[global::System.Text.Json.Serialization.JsonIgnore]");
            sb.AppendLine("public global::Everywhere.Configuration.SettingsItems SettingsItems { get; } = new();").AppendLine();
            sb.AppendLine("private void __BuildGeneratedSettingsItems()");
            sb.AppendLine("{");
            using (sb.Indent())
            {
                foreach (var meta in members)
                {
                    if (string.IsNullOrWhiteSpace(meta.HeaderKey))
                    {
                        // Report diagnostic for missing DynamicResourceKey
                        ctx.ReportDiagnostic(
                            Diagnostic.Create(
                                Diagnostics.EmptyHeaderKey,
                                meta.Symbol.Locations.FirstOrDefault(),
                                meta.Name));
                    }

                    EmitItemRecursive(sb, meta, $"item_{meta.Name.Replace(".", "_")}", meta.Name, "SettingsItems");
                }
            }
            sb.AppendLine("}").AppendLine();

            sb.AppendLine("partial void OnConstructed();").AppendLine();

            sb.Append("public ").Append(type.Name).AppendLine("()");
            sb.AppendLine("{");
            using (sb.Indent())
            {
                sb.AppendLine("__BuildGeneratedSettingsItems();");
                sb.AppendLine("OnConstructed();");
            }
            sb.AppendLine("}");
        }
        sb.AppendLine("}");

        ctx.AddSource($"{type.Name}.SettingsItems.g.cs", sb.ToString());
    }

    /// <summary>
    /// A settings item may be nested, e.g. Customizable`, so we use recursion here.
    /// </summary>
    /// <param name="sb"></param>
    /// <param name="metadata"></param>
    /// <param name="itemName"></param>
    /// <param name="bindingPath"></param>
    /// <param name="parentCollection"></param>
    private static void EmitItemRecursive(
        IndentedStringBuilder sb,
        PropertyMetadata metadata,
        string itemName,
        string bindingPath,
        string? parentCollection)
    {
        switch (metadata.Kind)
        {
            case ItemKind.Selection:
            {
                break;
            }
            case ItemKind.Customizable:
            {
                var innerType = ((INamedTypeSymbol)metadata.Type).TypeArguments[0];
                var innerMetadata = BuildPropertyMetadata(metadata.Symbol, metadata.AttributeOwner, metadata.Name, innerType);

                var inneritemName = itemName + "_inner";
                // Recursive call for the wrapped item
                EmitItemRecursive(
                    sb,
                    innerMetadata,
                    inneritemName,
                    $"{bindingPath}.BindableValue",
                    null);

                sb.AppendLine($"var {itemName} = new global::Everywhere.Configuration.SettingsCustomizableItem({inneritemName});");
                sb.Append($"{itemName}[!global::Everywhere.Configuration.SettingsCustomizableItem.ResetCommandProperty] = ");
                EmitBinding(sb, $"{bindingPath}.BindableValue", BindingMode.OneWay).AppendLine(";");

                // Special case from reflection code: set watermark for string properties
                if (innerMetadata.Kind == ItemKind.String)
                {
                    sb.Append($"{inneritemName}[!global::Everywhere.Configuration.SettingsStringItem.WatermarkProperty] = ");
                    EmitBinding(sb, $"{bindingPath}.DefaultValue", BindingMode.OneWay).AppendLine(";");
                }
                break;
            }
            default:
            {
                // Generate the 'new' expression for the specific SettingsItem type
                var newExpr = metadata.Kind switch
                {
                    ItemKind.Bool => "new global::Everywhere.Configuration.SettingsBooleanItem { IsNullable = false }",
                    ItemKind.NullableBool => "new global::Everywhere.Configuration.SettingsBooleanItem { IsNullable = true }",
                    ItemKind.String => "new global::Everywhere.Configuration.SettingsStringItem()",
                    ItemKind.Int => "new global::Everywhere.Configuration.SettingsIntegerItem()",
                    ItemKind.Double => "new global::Everywhere.Configuration.SettingsDoubleItem()",
                    ItemKind.Enum => "new global::Everywhere.Configuration.SettingsSelectionItem()",
                    _ =>
                        $"global::Everywhere.Configuration.SettingsTypedItem.TryCreate(typeof({metadata.Type.ToDisplayString().TrimEnd('?')})) ?? new global::Everywhere.Configuration.SettingsItem()"
                };
                sb.Append("var ").Append(itemName).Append(" = ").Append(newExpr).AppendLine(";");
                sb.Append($"{itemName}[!global::Everywhere.Configuration.SettingsItem.ValueProperty] = ");
                EmitBinding(sb, bindingPath, BindingMode.TwoWay).AppendLine(";");
                break;
            }
        }

        // Apply common properties (Header, Description, etc.)
        ApplyCommonMetadata(sb, itemName, metadata);
        // Apply IsEnabled/IsVisible bindings
        ApplyItemBindings(sb, itemName, metadata, bindingPath);
        // Apply type-specific properties from attributes (e.g., MaxLength)
        ApplyTypeSpecificMetadata(sb, itemName, metadata);
        // Handle nested items via [SettingsItems]
        ApplyGroup(sb, itemName, metadata, bindingPath);

        // Add the generated item to its parent collection
        if (!string.IsNullOrEmpty(parentCollection))
        {
            sb.AppendLine($"{parentCollection}.Add({itemName});").AppendLine();
        }
    }

    private static void ApplyCommonMetadata(IndentedStringBuilder sb, string itemName, in PropertyMetadata metadata)
    {
        var headerExpr = string.IsNullOrWhiteSpace(metadata.HeaderKey) ?
            "null" :
            $"new global::Everywhere.I18N.DynamicResourceKey({metadata.HeaderKey})";
        sb.AppendLine($"{itemName}.HeaderKey = {headerExpr};");

        if (metadata.DescriptionKey is { Length: > 0 })
        {
            sb.AppendLine($"{itemName}.DescriptionKey = new global::Everywhere.I18N.DynamicResourceKey({metadata.DescriptionKey});");
        }
    }

    /// <summary>
    /// Matches DynamicResourceKey("headerKey", "descriptionKey"), supports multi-line and spaces, e.g.
    /// DynamicResourceKey(
    ///     LocaleKey.CustomAssistant_Icon_Header,
    ///     LocaleKey.CustomAssistant_Icon_Description)
    /// </summary>
    /// <remarks>
    /// We need to parse the syntax ourselves because sometimes the attribute arguments are also SourceGenerated,
    /// and thus we cannot rely on ConstantValue of the attribute data.
    /// </remarks>
    private static readonly Regex DynamicResourceKeyRegex = new(
        @"DynamicResourceKey\s*\(\s*(?<headerKey>[^,)\r\n]+)(\s*,\s*(?<descriptionKey>[^)\r\n]+))?\s*\)",
        RegexOptions.Compiled | RegexOptions.CultureInvariant | RegexOptions.ExplicitCapture | RegexOptions.Singleline);

    private static PropertyMetadata BuildPropertyMetadata(ISymbol symbol, ISymbol attributeOwner, string name, ITypeSymbol? type = null)
    {
        type ??= ((IPropertySymbol)symbol).Type;
        var dynamicResourceKeyAttribute = attributeOwner.GetAttribute(KnownAttributes.DynamicResourceKey);
        var code = dynamicResourceKeyAttribute?.ApplicationSyntaxReference?.GetSyntax().ToString();
        var match = code is not null ? DynamicResourceKeyRegex.Match(code) : null;
        var headerKey = match?.Groups["headerKey"].Value.Trim() ?? string.Empty;
        var descriptionKey = match?.Groups["descriptionKey"].Success == true ? match.Groups["descriptionKey"].Value.Trim() : null;

        var kind = Classify(type);

        return new PropertyMetadata(symbol, attributeOwner, name, kind, type, headerKey, descriptionKey);
    }

    private static void ApplyTypeSpecificMetadata(IndentedStringBuilder sb, string itemName, in PropertyMetadata metadata)
    {
        switch (metadata.Kind)
        {
            case ItemKind.String when metadata.AttributeOwner.GetAttribute(KnownAttributes.SettingsStringItem) is { } attribute:
            {
                sb.AppendLine($"{itemName}.Watermark = {GetNamedArgValue(attribute, "Watermark", "null")};");
                sb.AppendLine($"{itemName}.MaxLength = {GetNamedArgValue(attribute, "MaxLength", "int.MaxValue")};");
                sb.AppendLine($"{itemName}.IsMultiline = {GetNamedArgValue(attribute, "IsMultiline", "false")};");
                sb.AppendLine(
                    $"{itemName}.TextWrapping = {GetNamedArgValue(attribute, "IsMultiline", false, "global::Avalonia.Media.TextWrapping.Wrap", "global::Avalonia.Media.TextWrapping.NoWrap")};");
                sb.AppendLine($"{itemName}.PasswordChar = {GetNamedArgValue(attribute, "IsPassword", false, "'*'", "'\\0'")};");
                sb.AppendLine($"{itemName}.Height = {GetNamedArgValue(attribute, "Height", "double.NaN")};");
                break;
            }
            case ItemKind.Int when metadata.AttributeOwner.GetAttribute(KnownAttributes.SettingsIntegerItem) is { } attribute:
            {
                sb.AppendLine($"{itemName}.MinValue = {GetNamedArgValue(attribute, "Min", "int.MinValue")};");
                sb.AppendLine($"{itemName}.MaxValue = {GetNamedArgValue(attribute, "Max", "int.MaxValue")};");
                sb.AppendLine($"{itemName}.IsSliderVisible = {GetNamedArgValue(attribute, "IsSliderVisible", "true")};");
                break;
            }
            case ItemKind.Double when metadata.AttributeOwner.GetAttribute(KnownAttributes.SettingsDoubleItem) is { } attribute:
            {
                sb.AppendLine($"{itemName}.MinValue = {GetNamedArgValue(attribute, "Min", "double.NegativeInfinity")};");
                sb.AppendLine($"{itemName}.MaxValue = {GetNamedArgValue(attribute, "Max", "double.PositiveInfinity")};");
                sb.AppendLine($"{itemName}.Step = {GetNamedArgValue(attribute, "Step", "0.1d")};");
                sb.AppendLine($"{itemName}.IsSliderVisible = {GetNamedArgValue(attribute, "IsSliderVisible", "true")};");
                break;
            }
            case ItemKind.Enum:
            {
                var enumTypeStr = metadata.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                sb.AppendLine($"{itemName}.ItemsSource = new global::System.Collections.Generic.List<global::Everywhere.Configuration.SettingsSelectionItem.Item>");
                sb.AppendLine("{");
                using (sb.Indent())
                {
                    var enumMembers = metadata.Type.GetMembers()
                        .OfType<IFieldSymbol>()
                        .Where(f => f.IsConst); // Enum members are constants

                    foreach (var member in enumMembers)
                    {
                        var memberAccess = $"{enumTypeStr}.{member.Name}";

                        // Check for [DynamicResourceKey] on the enum member
                        string? headerKey = null;
                        if (member.GetAttribute(KnownAttributes.DynamicResourceKey) is { } attr)
                        {
                            var code = attr.ApplicationSyntaxReference?.GetSyntax().ToString();
                            if (code is not null)
                            {
                                var match = DynamicResourceKeyRegex.Match(code);
                                headerKey = match.Groups["headerKey"].Value.Trim();
                            }
                            else if (attr.ConstructorArguments.Length > 0 &&
                                     attr.ConstructorArguments[0].Value?.ToString() is { Length: > 0 } headerKeyValue)
                            {
                                headerKey = $"\"{headerKeyValue}\"";
                            }
                        }

                        var resourceKeyExpr = headerKey is not null ?
                            $"new global::Everywhere.I18N.DynamicResourceKey({headerKey})":
                            $"new global::Everywhere.I18N.DirectResourceKey(\"{metadata.Type.Name}_{member.Name}\")";

                        sb.AppendLine($"new global::Everywhere.Configuration.SettingsSelectionItem.Item({resourceKeyExpr}, {memberAccess}, null),");
                    }
                }
                sb.AppendLine("};");
                break;
            }
        }
    }

    private static void ApplyItemBindings(
        IndentedStringBuilder sb,
        string itemName,
        in PropertyMetadata metadata,
        string bindingPath)
    {
        if (metadata.AttributeOwner.GetAttribute(KnownAttributes.SettingsItem) is not { } settingsItemAttribute) return;

        if (settingsItemAttribute.GetNamedArgument("IsEnabledBindingPath") is { IsNull: false, Value: string isEnabledBindingPath })
        {
            sb.Append($"{itemName}[!global::Everywhere.Configuration.SettingsItem.IsEnabledProperty] = ");
            EmitBinding(sb, isEnabledBindingPath, BindingMode.OneWay).AppendLine(";");
        }

        if (settingsItemAttribute.GetNamedArgument("IsVisibleBindingPath") is { IsNull: false, Value: string isVisibleBindingPath })
        {
            sb.Append($"{itemName}[!global::Everywhere.Configuration.SettingsItem.IsVisibleProperty] = ");
            EmitBinding(sb, isVisibleBindingPath, BindingMode.OneWay).AppendLine(";");
        }
    }

    private static void ApplyGroup(
        IndentedStringBuilder sb,
        string itemName,
        in PropertyMetadata metadata,
        string fullBindingPath)
    {
        if (metadata.AttributeOwner.GetAttribute(KnownAttributes.SettingsItems) is not { } settingsItemsAttribute) return;

        sb.AppendLine($"{itemName}.IsExpanded = {GetNamedArgValue(settingsItemsAttribute, "IsExpanded", "false")};");

        sb.Append($"{itemName}[!global::Everywhere.Configuration.SettingsItem.IsExpandableProperty] = ");
        EmitBinding(sb, metadata.Name, BindingMode.OneWay, "global::Avalonia.Data.Converters.ObjectConverters.IsNotNull");
        sb.AppendLine(";").AppendLine();

        var nestedProperties = metadata.Type.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p is { IsStatic: false, GetMethod: not null, IsImplicitlyDeclared: false })
            .Where(p => !p.IsHiddenItem())
            .Select(p => BuildPropertyMetadata(p, p, p.Name))
            .ToImmutableArray();

        foreach (var nestedMeta in nestedProperties)
        {
            var nesteditemName = $"{itemName}_{nestedMeta.Name.Replace(".", "_")}";
            // The new path is the current full path + the nested property name.
            var nestedPath = $"{fullBindingPath}.{nestedMeta.Name}";
            EmitItemRecursive(sb, nestedMeta, nesteditemName, nestedPath, $"{itemName}.Items");
        }
    }

    /// <summary>
    /// Emit the whole IBinding that represents the binding logic.
    /// for simple paths, this is just a Binding; for complex logical expressions, this may involve MultiBindings.
    /// The source of the binding is always `this`.
    /// So it can observe the whole path from the root object.
    /// e.g.
    /// new CompiledBinding
    /// {
    ///     Path = "SelectedWebSearchEngineProvider.EndPoint.ActualValue",
    ///     Source = this,
    ///     Mode = global::Avalonia.Data.BindingMode.TwoWay,
    ///     Converter = ...
    /// }
    /// </summary>
    private static IndentedStringBuilder EmitBinding(IndentedStringBuilder sb, string path, BindingMode mode, string? converter = null)
    {
        // This method translates a binding path string (which can be a logical expression)
        // into C# code that creates the appropriate Avalonia Binding or MultiBinding.
        void EmitExpression(string expression)
        {
            expression = expression.Trim();

            // Recursively parse logical OR expressions
            if (TryParseLogicalOperator(expression, "||", out var leftOr, out var rightOr))
            {
                sb.AppendLine("new global::Avalonia.Data.MultiBinding");
                sb.AppendLine("{");
                using (sb.Indent())
                {
                    sb.AppendLine("Converter = global::Avalonia.Data.Converters.BoolConverters.Or,");
                    sb.AppendLine("Mode = global::Avalonia.Data.BindingMode.OneWay,");
                    sb.AppendLine("Bindings =");
                    sb.AppendLine("{");
                    using (sb.Indent())
                    {
                        EmitExpression(leftOr);
                        sb.AppendLine(",");
                        EmitExpression(rightOr);
                        sb.AppendLine();
                    }
                    sb.AppendLine("}");
                }
                sb.Append("}");
                return;
            }

            // Recursively parse logical AND expressions
            if (TryParseLogicalOperator(expression, "&&", out var leftAnd, out var rightAnd))
            {
                sb.AppendLine("new global::Avalonia.Data.MultiBinding");
                sb.AppendLine("{");
                using (sb.Indent())
                {
                    sb.AppendLine("Converter = global::Avalonia.Data.Converters.BoolConverters.And,");
                    sb.AppendLine("Mode = global::Avalonia.Data.BindingMode.OneWay,");
                    sb.AppendLine("Bindings =");
                    sb.AppendLine("{");
                    using (sb.Indent())
                    {
                        EmitExpression(leftAnd);
                        sb.AppendLine(",");
                        EmitExpression(rightAnd);
                        sb.AppendLine();
                    }
                    sb.AppendLine("}");
                }
                sb.Append("}");
                return;
            }

            // Handle logical NOT
            if (expression.StartsWith("!"))
            {
                sb.AppendLine("new global::Avalonia.Data.MultiBinding");
                sb.AppendLine("{");
                using (sb.Indent())
                {
                    sb.AppendLine("Converter = new global::Avalonia.Data.Converters.FuncMultiValueConverter<bool, bool>(x => x.Any(y => !y)),");
                    sb.AppendLine("Bindings = ");
                    sb.AppendLine("{");
                    using (sb.Indent())
                    {
                        EmitExpression(expression[1..]);
                        sb.AppendLine(",");
                    }
                    sb.AppendLine("}");
                }
                sb.Append("}");
                return;
            }

            // Base case: a simple property path
            sb.Append($"new global::Avalonia.Data.Binding(\"{expression}\") {{ Source = this }}");
        }

        path = path.Trim();
        if (!path.Contains("||") && !path.Contains("&&") && !path.StartsWith("!"))
        {
            // Simple path, generate a direct binding
            sb.Append($"new global::Avalonia.Data.Binding(\"{path}\") {{ Source = this, Mode = global::Avalonia.Data.BindingMode.{mode}");
            if (converter is not null)
            {
                sb.Append($", Converter = {converter}");
            }
            sb.Append(" }");
        }
        else
        {
            // Complex logical path, start recursive parsing
            EmitExpression(path);
        }

        return sb;
    }

    private static bool TryParseLogicalOperator(string expression, string op, out string left, out string right)
    {
        left = string.Empty;
        right = string.Empty;
        var paren = 0;
        for (var i = expression.Length - 1; i >= 0; i--)
        {
            var c = expression[i];
            switch (c)
            {
                case ')': paren++; break;
                case '(': paren--; break;
            }

            if (paren == 0 && expression[i..].StartsWith(op))
            {
                left = expression[..i].Trim();
                right = expression[(i + op.Length)..].Trim();
                return true;
            }
        }
        return false;
    }

    private static string GetNamedArgValue(AttributeData attribute, string key, string defaultValue)
    {
        return attribute.GetNamedArgument(key) switch
        {
            { IsNull: false } arg => ToLiteral(arg.Value) ?? defaultValue,
            _ => defaultValue
        };
    }

    private static string GetNamedArgValue(AttributeData attribute, string key, bool defaultValue, string trueValue, string falseValue)
    {
        return attribute.GetNamedArgument(key) switch
        {
            { IsNull: false, Value: bool b } => b ? trueValue : falseValue,
            _ => defaultValue ? trueValue : falseValue
        };
    }

    private static string? ToLiteral(object? value)
    {
        return value switch
        {
            null => "null",
            string s => $"\"{s.Replace("\"", "\\\"")}\"",
            bool b => b ? "true" : "false",
            double d => $"{d}d",
            float f => $"{f}f",
            _ => value.ToString()
        };
    }

    private static ItemKind Classify(ITypeSymbol t)
    {
        if (t.GetAttribute(KnownAttributes.SettingsSelectionItem) is not null)
        {
            return ItemKind.Selection;
        }

        // Everywhere.Configuration.Customizable<T>
        if (t is INamedTypeSymbol { IsGenericType: true } nts &&
            nts.ConstructedFrom.ToDisplayString() == "Everywhere.Configuration.Customizable<T>")
        {
            return ItemKind.Customizable;
        }

        return t switch
        {
            { SpecialType: SpecialType.System_Boolean } => ItemKind.Bool,
            {
                OriginalDefinition: INamedTypeSymbol
                {
                    SpecialType: SpecialType.System_Nullable_T, TypeArguments: [{ SpecialType: SpecialType.System_Boolean }]
                }
            } => ItemKind.NullableBool,
            { SpecialType: SpecialType.System_String } => ItemKind.String,
            { SpecialType: SpecialType.System_Int32 } => ItemKind.Int,
            { SpecialType: SpecialType.System_Double } or { SpecialType: SpecialType.System_Single } => ItemKind.Double,
            { TypeKind: TypeKind.Enum } => ItemKind.Enum,
            _ => ItemKind.Unknown
        };
    }

    private sealed class IndentedStringBuilder
    {
        private readonly StringBuilder _stringBuilder = new();
        private string _indent = string.Empty;
        private bool _isLineStart = true;

        public IDisposable Indent()
        {
            var previousIndent = _indent;
            _indent += "    ";
            return new DisposableAction(() => _indent = previousIndent);
        }

        public IndentedStringBuilder Append(string text)
        {
            if (_isLineStart) _stringBuilder.Append(_indent);
            _stringBuilder.Append(text);
            _isLineStart = false;
            return this;
        }

        public IndentedStringBuilder AppendLine(string line)
        {
            if (_isLineStart) _stringBuilder.Append(_indent);
            _stringBuilder.AppendLine(line);
            _isLineStart = true;
            return this;
        }

        public IndentedStringBuilder AppendLine()
        {
            _stringBuilder.AppendLine();
            _isLineStart = true;
            return this;
        }

        public override string ToString() => _stringBuilder.ToString();

        private sealed class DisposableAction(Action action) : IDisposable
        {
            public void Dispose() => action();
        }
    }

    private enum ItemKind
    {
        Selection,
        Bool,
        NullableBool,
        String,
        Int,
        Double,
        Customizable,
        Enum,
        SettingsControl,
        Unknown
    }

    private readonly record struct PropertyMetadata(
        ISymbol Symbol,
        ISymbol AttributeOwner,
        string Name,
        ItemKind Kind,
        ITypeSymbol Type,
        string HeaderKey,
        string? DescriptionKey
    );

    private enum BindingMode
    {
        OneWay,
        OneWayToSource,
        TwoWay,
        OneTime
    }
}